  </main>
</div>
<script>
  // Build TOC from actual H1/H2/H3 in <main>
  (function(){
    // --- utils ---
    const slug = (s) => s.toLowerCase().trim()
      .replace(/[^a-z0-9\s-]/g, "")
      .replace(/\s+/g, "-").replace(/-+/g, "-");

    // Ensure every H1/H2/H3 has an id
    const heads = Array.from(document.querySelectorAll("main h1, main h2, main h3")).map(el => {
      if (!el.id) el.id = slug(el.textContent || "section");
      return el;
    });

    // Group headings under their parents: H1 -> H2[] -> H3[]
    const h1s = [];
    let curH1 = null, curH2 = null;
    for (const h of heads) {
      if (h.tagName === "H1") {
        curH1 = { el: h, h2s: [] }; h1s.push(curH1); curH2 = null;
      } else if (h.tagName === "H2" && curH1) {
        curH2 = { el: h, h3s: [] }; curH1.h2s.push(curH2);
      } else if (h.tagName === "H3" && curH2) {
        curH2.h3s.push(h);
      }
    }

    // Render TOC: H1 (details.lvl-1) -> H2 (details.lvl-2) -> H3 (links)
    const toc = document.getElementById("toc");
    const headingToAnchor = new Map(); // map H2 element -> its <a> in TOC
    for (const h1 of h1s) {
      const d1 = document.createElement("details");
      d1.className = "lvl-1"; d1.open = true;
      const s1 = document.createElement("summary");
      const a1 = document.createElement("a");
      a1.href = "#top";
      a1.textContent = h1.el.textContent;
			headingToAnchor.set(h1.el, a1);
      s1.appendChild(a1); d1.appendChild(s1);

      const ul2 = document.createElement("ul");
      for (const h2 of h1.h2s) {
        const li2 = document.createElement("li");
        const d2 = document.createElement("details"); d2.className = "lvl-2";
        const s2 = document.createElement("summary");
        const a2 = document.createElement("a"); a2.href = `#${h2.el.id}`; a2.textContent = h2.el.textContent;
        s2.appendChild(a2); d2.appendChild(s2);

        // --- keep reference so we can toggle .active on scroll ---
				headingToAnchor.set(h2.el, a2);

        if (h2.h3s.length) {
          const ul3 = document.createElement("ul"); ul3.className = "h3-list";
          for (const h3 of h2.h3s) {
            const li3 = document.createElement("li");
            const a3 = document.createElement("a");
						a3.href = `#${h3.id}`;
						a3.textContent = h3.textContent;
						headingToAnchor.set(h3, a3);
            li3.appendChild(a3); ul3.appendChild(li3);
          }
          d2.appendChild(ul3);
        }
        li2.appendChild(d2); ul2.appendChild(li2);
      }
      d1.appendChild(ul2);
      const li1 = document.createElement("li"); li1.appendChild(d1); toc.appendChild(li1);
    }

    // Expand all = open every H2 details (so H3â€™s are visible)
    const btn = document.getElementById('toggleExpand');
    const anyH3 = heads.some(h => h.tagName === "H3");

    if (!anyH3) {
      // hide the button if no H3
      if (btn) btn.style.display = "none";
    } else {
			btn.addEventListener("click", () => {
				const groups = document.querySelectorAll("#toc .lvl-2");
				const anyClosed = Array.from(groups).some(d => !d.open);

				// User intent: treat this as manual; wipe auto flags first
				groups.forEach(d => d.removeAttribute("data-auto-opened"));

				groups.forEach(d => d.open = anyClosed);
				btn.textContent = anyClosed ? "Collapse all" : "Expand all";
			});
		}

    // Optional: keep details open when clicking its summary link
    toc.addEventListener("click", (e) => {
      if (e.target.tagName === "A" && e.target.parentElement.tagName === "SUMMARY") {
        // allow default (anchor jump), but avoid double-toggle flicker
        e.target.parentElement.parentElement.open = true;
      }
    });

		// ---- Aside visibility control (show after first H2 becomes active) ----
		const asideEl = document.querySelector("aside");
    // Hide aside initially (keeps layout space; no jump)
		if (asideEl) {
			asideEl.classList.add("toc-hidden");
			asideEl.setAttribute("aria-hidden", "true");
		}

		const firstH2 = heads.find(h => h.tagName === "H2") || null;
		let asideShownOnce = false;

		function maybeShowAsideOn(el) {
			// Only trigger once: when the *first H2* becomes the active heading
			if (!asideShownOnce && firstH2 && el === firstH2 && asideEl) {
				asideEl.classList.remove("toc-hidden");
				asideEl.removeAttribute("aria-hidden");
				asideShownOnce = true; // lock it; never hide again
			}
		}

		// ===== Active heading tracking (H1 + H2 + H3) =====
		const TOP_THRESHOLD = 8; // px; set to fixed header height if you have one
		let ticking = false;

    // Keep arrays handy
		const trackedElems = Array.from(headingToAnchor.keys());   // H1/H2/H3 in DOM order
		const trackedAnchors = Array.from(headingToAnchor.values());

		function clearActive() {
			trackedAnchors.forEach(a => a.classList.remove("active"));
		}

		function setActiveFor(el) {
			const a = headingToAnchor.get(el);
			if (!a) return;

			clearActive();
			a.classList.add("active");

			// Close previously auto-opened groups (but keep manual ones)
			document.querySelectorAll('#toc .lvl-2[data-auto-opened="1"]').forEach(d => {
				const currentDetails = a.closest(".lvl-2");
				if (d !== currentDetails) {
					d.open = false;
					d.removeAttribute("data-auto-opened");
				}
			});

			// Open the corresponding H2 group if this is an H2 or H3 anchor
			const lvl2 = a.closest(".lvl-2");
			if (lvl2) {
				if (!lvl2.open) {
					// Open and mark as auto-opened
					lvl2.open = true;
					lvl2.setAttribute("data-auto-opened", "1");
				} else if (!lvl2.hasAttribute("data-auto-opened")) {
					// Already manually opened; leave it as manual
				}
			}
		}

		function onScroll() {
			if (ticking) return;
			ticking = true;
			requestAnimationFrame(() => {
				ticking = false;
				if (!trackedElems.length) return;

				// At bottom? -> activate very last heading (even if it's an H3)
				const doc = document.documentElement;
				const atBottom = Math.ceil(window.scrollY + window.innerHeight) >= (doc.scrollHeight - 1);
				if (atBottom) {
					setActiveFor(trackedElems[trackedElems.length - 1]);
					return;
				}

				// Find the last heading whose top is above threshold
				let current = null;
				for (const el of trackedElems) {
					const top = el.getBoundingClientRect().top;
					if (top <= TOP_THRESHOLD) current = el; else break;
				}
				if (current) {
					maybeShowAsideOn(current);
					setActiveFor(current);
				} else {
					clearActive();
				}
			});
		}

		window.addEventListener("scroll", onScroll, { passive: true });
		window.addEventListener("resize", onScroll);
		window.addEventListener("load", onScroll);
		onScroll();
  })();
</script>
